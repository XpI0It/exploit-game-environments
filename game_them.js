export class QuestionController {
  constructor(questions, answerCallBack = () => { }) {
    this.gameTime = 20;
    this.totalTime = 0;
    this.attempts = 3;
    this.wrongElms = [];
    this.qContainer = document.getElementById('container');
    this.question = document.getElementById("question");
    this.choices = Array.from(document.getElementsByClassName("choice-text"));
    this.progressText = document.getElementById("progressText");
    this.scoreText = document.getElementById("score");
    this.progressBarFull = document.getElementById("progressBarFull");
    this.attemptsElm = document.getElementById('attempts')
    this.currentQuestion = {};
    this.acceptingAnswers = false;
    this.score = 0;
    this.questionCounter = 0;
    this.availableQuesions = [];
    this.questions = questions;
    this.time = document.getElementById("timer");
    this.startingTime = this.gameTime; // time alloted for 1 question
    this.time.innerHTML = "Time Left: " + this.startingTime;

    this.answerCallBack = answerCallBack;

    this.CORRECT_BONUS = 10;
    this.MAX_QUESTIONS = 3;

    this.choices.forEach((choice) => {
      choice.addEventListener("click", (e) => {
        if (!this.acceptingAnswers) return;
        this.acceptingAnswers = false;

        if (this.ticker) clearInterval(this.ticker);
        this.ticker = undefined;

        const selectedChoice = e.target;
        const selectedAnswer = selectedChoice.dataset["number"];
        const correct = selectedAnswer == this.currentQuestion.answer;


        const classToApply = correct ? "correct" : "incorrect";

        localStorage.setItem("mostRecentScore", this.score);

        selectedChoice.parentElement.classList.add(classToApply);

        if (correct) {
          this.incrementScore(this.CORRECT_BONUS);
          this.totalTime += (this.gameTime - this.startingTime);
          setTimeout(() => {
            selectedChoice.parentElement.classList.remove(classToApply);
            this.hide();
            answerCallBack(true, this.score, this.totalTime);
          }, 1000);
        }
        else {
          this.attempts--;
          this.attemptsElm.innerText = this.attempts;
          if (this.attempts > 0) {
            setTimeout(() => {
              selectedChoice.parentElement.classList.remove(classToApply);
              this.ticker = setInterval(() => this.updateTimer(this), 1000);
              this.acceptingAnswers = true;
            }, 1000);
          }
          else {
            setTimeout(() => {
              selectedChoice.parentElement.classList.remove(classToApply);
              this.hide();
              answerCallBack(correct, this.score, this.totalTime);
            }, 1000);
          }
        }


        // Question ends


      });
    });



    // Init question
    this.questionCounter = 0;
    this.score = 0;
    this.availableQuesions = [...questions];
  }

  show() {
    this.qContainer.style.zIndex = 99;
  }

  hide() {
    document.getElementById('postScore').innerText = 'Score: ' + this.score;
    this.qContainer.style.zIndex = 1;
  }

  next() {
    this.startingTime = this.gameTime;
    this.time.innerHTML = "Time Left: " + this.startingTime
    this.ticker = setInterval(() => this.updateTimer(this), 1000);
    this.getNewQuestion();
    this.show();
  }

  incrementScore(num) {
    this.score += num;
    this.scoreText.innerText = this.score;
  };

  // timeout
  updateTimer(cont) {
    cont.startingTime--;
    if (cont.startingTime == -1) {
      clearInterval(cont.ticker);
      cont.hide();
      cont.answerCallBack(false);
    } else cont.time.innerHTML = "Time Left: " + cont.startingTime;
  }

  getNewQuestion() {
    if (this.availableQuesions.length === 0 || this.questionCounter >= this.MAX_QUESTIONS) {
      localStorage.setItem("mostRecentScore", this.score);
      //go to the end page
      //return window.location.assign('/game/ransomeware/end');
      // return (location.href = "/game/ransomeware/end");
      location.reload();
      return;
    }
    this.questionCounter++;
    this.progressText.innerText = `Question ${this.questionCounter}/${this.MAX_QUESTIONS}`;
    //Update the progress bar
    this.progressBarFull.style.width = `${(this.questionCounter / this.MAX_QUESTIONS) * 100}%`;

    const questionIndex = Math.floor(Math.random() * this.availableQuesions.length);
    this.currentQuestion = this.availableQuesions[questionIndex];
    this.question.innerText = this.currentQuestion.question;


    this.choices.forEach((choice) => {
      const number = choice.dataset["number"];
      choice.innerText = this.currentQuestion["choice" + number];
    });

    this.availableQuesions.splice(questionIndex, 1);
    this.acceptingAnswers = true;
  };
}
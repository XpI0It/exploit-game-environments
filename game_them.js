export class QuestionController {
  constructor(questions, answerCallBack = () => { }) {
    this.qContainer = document.getElementById('container');
    this.question = document.getElementById("question");
    this.choices = Array.from(document.getElementsByClassName("choice-text"));
    this.progressText = document.getElementById("progressText");
    this.scoreText = document.getElementById("score");
    this.progressBarFull = document.getElementById("progressBarFull");
    this.currentQuestion = {};
    this.acceptingAnswers = false;
    this.score = 0;
    this.questionCounter = 0;
    this.availableQuesions = [];
    this.questions = questions;
    this.time = document.getElementById("timer");
    this.startingTime = 20; // time alloted for 1 question
    this.time.innerHTML = "Time Left: " + this.startingTime;

    this.answerCallBack = answerCallBack;

    this.CORRECT_BONUS = 10;
    this.MAX_QUESTIONS = 3;

    this.choices.forEach((choice) => {
      choice.addEventListener("click", (e) => {
        if (!this.acceptingAnswers) return;

        this.acceptingAnswers = false;
        const selectedChoice = e.target;
        const selectedAnswer = selectedChoice.dataset["number"];
        const correct = selectedAnswer == this.currentQuestion.answer;


        const classToApply = correct ? "correct" : "incorrect";

        localStorage.setItem("mostRecentScore", this.score);

        if (classToApply === "correct") {
          this.incrementScore(this.CORRECT_BONUS);
        }

        selectedChoice.parentElement.classList.add(classToApply);
        if (this.ticker) clearInterval(this.ticker);

        // Question ends


        setTimeout(() => {
          selectedChoice.parentElement.classList.remove(classToApply);
          this.hide();
          answerCallBack(correct);
        }, 1000);
      });
    });



    // Init question
    this.questionCounter = 0;
    this.score = 0;
    this.availableQuesions = [...questions];
  }

  show() {
    this.qContainer.style.zIndex = 99;
  }

  hide() {
    this.qContainer.style.zIndex = 1;
  }

  next() {
    this.ticker = setInterval(() => this.updateTimer(this), 1000);
    this.startingTime = 20;
    this.getNewQuestion();
    this.show();
  }

  incrementScore(num) {
    this.score += num;
    this.scoreText.innerText = this.score;
  };

  // timeout
  updateTimer(cont) {
    cont.startingTime--;
    if (cont.startingTime == -1) {
      clearInterval(cont.ticker);
      cont.hide();
      cont.answerCallBack(false);
    } else cont.time.innerHTML = "Time Left: " + cont.startingTime;
  }

  getNewQuestion() {
    if (this.availableQuesions.length === 0 || this.questionCounter >= this.MAX_QUESTIONS) {
      localStorage.setItem("mostRecentScore", this.score);
      //go to the end page
      //return window.location.assign('/game/ransomeware/end');
      // return (location.href = "/game/ransomeware/end");
      location.reload();
      return;
    }
    this.questionCounter++;
    this.progressText.innerText = `Question ${this.questionCounter}/${this.MAX_QUESTIONS}`;
    //Update the progress bar
    this.progressBarFull.style.width = `${(this.questionCounter / this.MAX_QUESTIONS) * 100}%`;

    const questionIndex = Math.floor(Math.random() * this.availableQuesions.length);
    this.currentQuestion = this.availableQuesions[questionIndex];
    this.question.innerText = this.currentQuestion.question;


    this.choices.forEach((choice) => {
      const number = choice.dataset["number"];
      choice.innerText = this.currentQuestion["choice" + number];
    });

    this.availableQuesions.splice(questionIndex, 1);
    this.acceptingAnswers = true;
  };
}
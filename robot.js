import { AnimationMixer, Clock, LoopOnce, Vector3 } from "three";
import { FBXLoader } from "three/examples/jsm/loaders/fbxloader";

export class Robot {
    constructor(onLoad) {
        this.modelLoader = new FBXLoader();
        this.modelLoader.load('/static/3d/bot.fbx', (model) => {
            this.model = model;
            this.model.scale.set(0.1, 0.1, 0.1);
            this.animationMixer = new AnimationMixer(model);

            this.walkingClip = this.animationMixer.clipAction(model.animations[10]);
            this.jumpingClip = this.animationMixer.clipAction(model.animations[13]);
            this.standingClip = this.animationMixer.clipAction(model.animations[4]);
            this.idleClip = this.animationMixer.clipAction(model.animations[5]);
            this.danceClip = this.animationMixer.clipAction(model.animations[3]);
            this.deathClip = this.animationMixer.clipAction(model.animations[9]);
            this.waveClip = this.animationMixer.clipAction(model.animations[8]);

            this.distanceToWalk = 0;
            this.walkingSpeed = 25;
            this.jumpingBoost = 0;
            this.walkingClip.clampWhenFinished = true;

            window.robot = this;
            window.robotJump = this.jumpingClip;

            this.waveClip.loop = LoopOnce;
            this.waveClip.clampWhenFinished = true;

            this.walkingMultiplier = 1;

            this.isWalking = false;
            this.isJumping = false;
            this.jumpingClipId = this.jumpingClip.getClip().uuid;
            this.walkingClipId = this.walkingClip.getClip().uuid;
            this.deathClipId = this.deathClip.getClip().uuid;
            this.waveClipId = this.waveClip.getClip().uuid;
            this.sequencing = false;

            this.clock = new Clock();
            this.next = () => { };

            this.animationMixer.addEventListener('finished', (d, e) => this.__animFinishListener(d, e, this));
            this.idleClip.timeScale = 0.1;
            this.__gameLoop(this);

            onLoad(this);
        });
    }

    __animFinishListener(dispatch, event, robot) {
        window.roboDispatch = dispatch;
        window.robotEvent = event;

        let handle = dispatch;
        if (handle == undefined) {
            handle = event;
        }

        if (handle.action.getClip().uuid == robot.jumpingClipId) {
            robot.isJumping = false;
            robot.jumpingClip.fadeOut(0.1);
        }
        if (handle.action.getClip().uuid == robot.waveClipId) {
            robot.waveClip.fadeOut(0.1);
            robot.idleClip.fadeIn(0.1);
            robot.idleClip.play();
        }

        if (robot.nextAction) robot.nextAction(robot, handle);
    }

    pass(jumpDistance, walkDistance) {
        if (this.sequencing) return;
        this.sequencing = true;
        this.jump(jumpDistance);
        this.nextAction = (robot, handle) => {
            if (handle.action.getClip().uuid != robot.jumpingClipId) return;
            robot.walk(walkDistance);
            robot.nextAction = undefined;
        }
    }

    fail() {
        this.animationMixer.stopAllAction();
        this.deathClip.enabled = true;
        this.deathClip.loop = LoopOnce;
        this.deathClip.clampWhenFinished = true;
        this.deathClip.play();
    }

    win() {
        this.animationMixer.stopAllAction();
        this.danceClip.play();
    }

    wave() {
        this.waveClip.reset().play();
    }

    walk(distance = 1) {
        this.distanceToWalk = distance;
        if (!this.isWalking) {
            this.isWalking = true;
            this.walkingClip.reset();
            this.walkingClip.fadeIn(0.1);
            this.walkingClip.play();
        }
    }



    jump(distance = 84) {
        if (this.isJumping) return;
        this.isJumping = true;
        this.distanceToJump = distance;
        this.jumpingSpeed = distance / 0.25;

        this.jumpingClip.reset();
        this.jumpingClip.repetitions = 1;
        this.jumpingClip.clampWhenFinished = true;
        this.jumpingClip.weight = 4;
        this.jumpingClip.play();
    }

    rotate(_angle) {
        if (this.isWalking) {
            this.angle = _angle * this.walkingMultiplier;
        } else {

            this.angle = _angle;
        }
    }

    __gameLoop(robot) {
        if (robot.clock == undefined) {
            robot.clock = new Clock();
        }

        const rotationSpeed = 1;
        const delta = robot.clock.getDelta();
        const model = robot.model;
        const deltaAngle = rotationSpeed * delta;

        if (robot.angle > 0) {
            model.rotation.y += deltaAngle;
            const newAngle = robot.angle - deltaAngle;
            robot.angle = newAngle < 0 ? 0 : newAngle;
        }
        if (robot.angle < 0) {
            model.rotation.y -= deltaAngle;
            const newAngle = robot.angle + deltaAngle;
            robot.angle = newAngle > 0 ? 0 : newAngle;
        }

        const roboAngle = model.rotation.y;

        if (robot.distanceToWalk > 0) {
            const distance = robot.walkingMultiplier * (robot.walkingSpeed + robot.jumpingBoost) * delta;
            const x = Math.sin(roboAngle) * distance;
            const y = Math.cos(roboAngle) * distance;
            robot.model.position.add(new Vector3(x, 0, y));
            robot.distanceToWalk = Math.max(robot.distanceToWalk - distance, 0);

        } else if (robot.isWalking) {
            robot.walkingClip.fadeOut(0.1);
            robot.isWalking = false;
            robot.sequencing = false;
            robot.next();
        }

        if (this.isJumping) {
            if (this.jumpingClip.time > 0.2 && this.jumpingClip.time < 0.45) {
                let deltaDistance = delta * robot.jumpingSpeed;
                deltaDistance += Math.min(0, robot.distanceToJump - deltaDistance);
                const x = Math.sin(roboAngle) * deltaDistance;
                const y = Math.cos(roboAngle) * deltaDistance;
                robot.model.position.add(new Vector3(x, 0, y));
                robot.distanceToJump = Math.max(robot.distanceToJump - deltaDistance, 0);
            }
        }

        robot.animationMixer.update(delta);


        requestAnimationFrame(() => robot.__gameLoop(robot));
    }

}
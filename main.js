import './style.css'
import * as three from "three";
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { Robot } from './robot';
import { AmbientLight, AxesHelper, BackSide, Box3, CameraHelper, Clock, Color, DirectionalLight, DirectionalLightHelper, FogExp2, GridHelper, Mesh, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, PerspectiveCamera, PlaneGeometry, PointLight, Scene, SphereGeometry, TextureLoader, Vector3, WebGLRenderer } from 'three';
import { makeSmoke } from './smoke';
import { makeColony } from './building_colony';
import { getClouds } from './clouds';
import { getCloudCluster } from './cloud_cluster';
import { makeBuilding } from './building';
import { QuestionController } from './game_them';



const clock = new Clock();
const textureLoader = new TextureLoader();
const plotHeight = 1200;
const robotAab = new Box3();
const roboSize = new Vector3();

const buildingLength = 150;
const gutter = 30;
const questions = 4;

const keyPresses = {};
const scene = new Scene();
scene.background = new Color(0xff000000);
scene.fog = new FogExp2(0xff111111, 0.0015);

const globe = new Mesh(new SphereGeometry(2000), new MeshStandardMaterial({ color: 0xff000000, side: BackSide }));
scene.add(globe);


const devCam = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
devCam.position.set(-70, 50, 20);

const playerCam = new PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 5000);
playerCam.position.set(-150, 70, 20);
const cameraHelper = new CameraHelper(playerCam);

let camera = playerCam;

function moveCameraUp() {

}

function moveCameraDown() {

}

function displayLost() {
  const a = document.querySelector('#lostMessage>a');
  const elm = document.getElementById('lostMessage');
  if (a) {
    a.href = '/game/ransomeware/end';
  }
  if (elm) {
    elm.style.display = 'flex';
  }
  else {
    setTimeout(() => {
      location.href = '/game/ransomeware/end';
    }, 2000);
  }
}


const renderer = new WebGLRenderer({ canvas: document.querySelector('#renderer'), antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

const gridHelper = new GridHelper(400, 50);
const axisHelper = new AxesHelper(600);

let stepCount = 0;
let questionData, questionController;
const robot = new Robot(async (robo) => {
  const model = robo.model;

  // model.animations.forEach((clip, index, arr) => {
  //   console.log(index + clip.name + clip.duration);
  // })

  scene.add(model);

  robotAab.setFromObject(model);
  robotAab.getSize(roboSize);

  model.position.z = roboSize.z / 2;

  const respond = (correct) => {
    stepCount++;
    if (correct) {
      let walkDistance = buildingLength - roboSize.z;
      if (stepCount == questionData.length) {
        walkDistance -= 30;
      }
      robo.pass(gutter + roboSize.z, walkDistance);
    }
    else {
      displayLost();
      robo.fail();
    }
  }

  const resp = await fetch('/res/questions.json');
  questionData = await resp.json();
  questionController = new QuestionController(questionData, respond);

  const next = () => {
    if (stepCount < questionData.length) {
      questionController.next();
    }
    else {
      robo.win();
      const message = document.getElementById('message');
      message.textContent = 'You Win';
      message.style.color = 'green';
      displayLost();
    }
  }

  robo.next = next;

  // window.onclick = () => {
  //   questionController.next();
  // }

  robo.walk(buildingLength - roboSize.z);
  requestAnimationFrame(onLoaded);
});

const ambientLight = new AmbientLight(0xffffff, 0.4);

const moonDisplacementMap = textureLoader.load('displacement.jpg');
const moonTexture = textureLoader.load('moon.jpg');
const moonBody = new Mesh(new SphereGeometry(200, 1800, 1800), new MeshPhongMaterial({ map: moonTexture, displacementMap: moonDisplacementMap, displacementScale: 0.0, bumpMap: moonDisplacementMap, bumpScale: 0.04, reflectivity: 0, shininess: 0, emissive: 0xffffffff, emissiveMap: moonTexture, emissiveIntensity: 12 }));
const moon = new PointLight(0xffffff, 1, 5000);
moon.position.set(1200, 350, 0);
moonBody.position.set(1200, 350, 0);

const smokeC = makeSmoke();
smokeC.position.set(1300, 100, 0);

const smokeL = makeSmoke(650, 15);
smokeL.position.set(1100, 60, -window.innerWidth / 2);

const smokeR = makeSmoke(650, 15);
smokeR.position.set(1100, 70, window.innerWidth / 2);

const colony = makeColony();
colony.position.x = 400;
const colonyAab = new Box3();
colonyAab.setFromObject(colony);
colony.position.add(new Vector3(0, -plotHeight, -(colonyAab.getSize(new Vector3()).z / 2)));

//Spot light

const robotLight1 = new DirectionalLight(0xffffffff, 0.4);
const roboLight1Helper = new DirectionalLightHelper(robotLight1);
const robotLight2 = new DirectionalLight(0xffffffff, 0.4);
const roboLight2Helper = new DirectionalLightHelper(robotLight2);

// Clouds

const sphereCloud = getClouds(window.innerWidth);
// const cloudAab = new Box3();
// cloudAab.setFromObject(sphereCloud);
// cloudCluster.position.set(400, -600, -cloudAab.getSize(new Vector3()).z/2);
sphereCloud.position.set(600, -window.innerWidth, 0);

// Cloud Cluster

const cloudCluster = getCloudCluster();
const clusterAab = new Box3();
clusterAab.setFromObject(cloudCluster);
const clusterCenter = clusterAab.getCenter(new Vector3());
cloudCluster.position.y - 300;
cloudCluster.position.x - 100;

const cloudLight = new PointLight(0xffffffff, 1, 8000, 0);
cloudLight.position.set(clusterCenter.x, clusterCenter.y, clusterCenter.z);



// Lily pad

const buildingAab = new Box3();

const buildings = [];
let offset = buildingLength / 2;
for (let i = 0; i < questions; i++) {
  const building = makeBuilding(50, 120, buildingLength);
  building.position.z = offset;
  offset += buildingLength + gutter;
  buildingAab.setFromObject(building);
  building.position.y = -(buildingAab.getSize(new Vector3()).y - 4);
  buildings.push(building);
}

const finishTexture = textureLoader.load('finish.png');
const finishSurface = new Mesh(new PlaneGeometry(120, 30), new MeshStandardMaterial({ map: finishTexture, metalness: 0.001, roughness: 0.1 }));
finishSurface.rotateX(-Math.PI / 2);
finishSurface.position.z = offset - (gutter + buildingLength);

// const lastBuilding = makeBuilding(50, 120, buildingLength);
// lastBuilding.position.z = offset;
// buildingAab.setFromObject(lastBuilding);
// lastBuilding.position.y = -buildingAab.getSize(new Vector3()).y;
// buildings.push(lastBuilding);



// Scene

scene.add(
  // gridHelper,
  axisHelper,
  ambientLight,
  moon,
  moonBody,
  smokeC,
  smokeL,
  smokeR,
  // cameraHelper,
  playerCam,
  colony,
  robotLight1,
  robotLight2,
  roboLight1Helper,
  roboLight2Helper,
  // surface,
  sphereCloud,
  cloudCluster,
  finishSurface,
  // cloudLight,
  ...buildings,
);

renderer.render(scene, camera);

const controls = new OrbitControls(devCam, renderer.domElement);

// const sunOrbitRadius = 200;
// const sunOrbitSpeed = 1;
// let sunAngle = 0;

// function rotateSun(delta = 1) {
//   sunAngle += sunOrbitSpeed * delta;
//   const y = Math.sin(sunAngle) * sunOrbitRadius;
//   const z = Math.cos(sunAngle) * sunOrbitRadius;
//   moon.position.y = y;
//   moon.position.z = z;
//   moonBody.position.y = y;
//   moonBody.position.z = z;
// }

function onLoaded() {
  document.getElementById('loading').style.zIndex = 0;
  gameLoop();
  // requestAnimationFrame(gameLoop);
}

function gameLoop() {
  requestAnimationFrame(gameLoop);

  // cloudCluster.lookAt(playerCam.position);
  // // cloudCluster.rotateX(-Math.PI / 2);
  // cloudCluster.rotateZ(-Math.PI / 2);
  let robotLength = 0;


  moonBody.rotateY(0.0001);
  moonBody.rotateZ(0.0002);

  if (robot.model) {
    robotLength = robotAab.getSize(new Vector3()).z;
    const roboModel = robot.model;
    const robotPos = roboModel.position.clone();

    robotLight1.position.set(robotPos.x - 100, robotPos.y + 50, robotPos.z);
    robotLight1.target.position.set(robotPos.x, robotPos.y, robotPos.z);
    robotLight1.target.updateWorldMatrix();

    robotLight2.position.set(robotPos.x, robotPos.y + 100, robotPos.z);
    robotLight2.target.position.set(robotPos.x, robotPos.y, robotPos.z);
    robotLight2.target.updateWorldMatrix();

    playerCam.position.set(robotPos.x, robotPos.y, robotPos.z);
    playerCam.position.add(new Vector3(-300, 70, 20));
    playerCam.lookAt(roboModel.position.clone().add(new Vector3(0, 50, 20)));
  }

  const delta = clock.getDelta();
  // rotateSun(delta);

  if (keyPresses['f']) {
    robot.fail()

  } else if (keyPresses['p']) {
    robot.pass(gutter + roboSize.z, buildingLength - roboSize.z);
  }

  // if (keyPresses['w'] == true) {
  //   robot.walk();
  // }
  // if (keyPresses['a']) {
  //   robot.rotate(0.1);
  // } else if (keyPresses['d']) {
  //   robot.rotate(-0.1);
  // }
  // if (keyPresses[' ']) {
  //   robot.jump(20 + (robotLength));
  // }
  // if (keyPresses['Control']) {
  //   robot.punch();
  // }

  smokeC.rotation.y += 0.0001;
  smokeC.rotation.x += 0.0005;
  smokeL.rotation.y += 0.0001;
  smokeL.rotation.x += 0.0005;
  smokeR.rotation.y += 0.0001;
  smokeR.rotation.x += 0.0005;

  // sphereCloud.rotation.x += 0.00001;

  controls.update();


  renderer.render(scene, camera);
}

function keyPressTracker(ev) {
  console.log(ev.key);
  keyPresses[ev.key] = ev.type == 'keydown';
}

function changeCamera() {
  if (camera.uuid == devCam.uuid) {
    camera = playerCam;
  } else {
    camera = devCam;
  }
}

window.onkeyup = keyPressTracker;
window.onkeydown = keyPressTracker;

// const btn = document.getElementById('btn');
// if (btn != null) {
//   btn.addEventListener('click', (ev) => {
// if (camera.uuid == devCam.uuid) {
//   camera = playerCam;
// } else {
//   camera = devCam;
// }
//   })
// }


window.changeCamera = changeCamera;
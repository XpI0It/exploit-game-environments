import "./style.css";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { Robot } from "./robot";
import {
  AmbientLight,
  AxesHelper,
  BackSide,
  Box3,
  Clock,
  Color,
  DirectionalLight,
  DirectionalLightHelper,
  FogExp2,
  Mesh,
  MeshPhongMaterial,
  MeshStandardMaterial,
  PerspectiveCamera,
  PlaneGeometry,
  PointLight,
  Scene,
  SphereGeometry,
  TextureLoader,
  Vector3,
  WebGLRenderer,
} from "three";
import { makeSmoke } from "./smoke";
import { makeColony } from "./building_colony";
import { getClouds } from "./clouds";
import { getCloudCluster } from "./cloud_cluster";
import { makeBuilding } from "./building";
import { QuestionController } from "./game_them";

const textureLoader = new TextureLoader();

function loadTexture(name) {
  return textureLoader.load("/static/3d/" + name);
}

class StageConfig {
  constructor(
    baseColor = 0xff000000,
    fogColor = 0xff111111,
    fogIntensity = 0.0015,
    slowStars = false,
    moonTexture = loadTexture("moon.jpg"),
    displacementMap = loadTexture("displacement.jpg"),
    moonColor = 0xffffffff
  ) {
    this.baseColor = baseColor;
    this.fogColor = fogColor;
    this.fogIntensity = fogIntensity;
    this.slowStars = slowStars;
    this.moonTexture = moonTexture;
    this.displacementMap = displacementMap;
    this.moonColor = moonColor;
  }
}

const stageNum = 2;

let stage;
switch (stageNum) {
  case 1:
    const sun = loadTexture("sun.jpg");
    stage = new StageConfig(
      0xff00afdb,
      0xff00afdb,
      0.001,
      true,
      sun,
      sun,
      0xffff8215
    );
    break;

  case 2:
    const bsun = loadTexture("bsun.png");
    stage = new StageConfig(
      0xff00afdb,
      0xffe8a05b,
      0.0015,
      true,
      bsun,
      bsun,
      0xffe06005
    );
    break;

  case 4:
    const bmoon = loadTexture("bmoon.png");
    stage = new StageConfig(
      0xff000000,
      0xff111111,
      0.0013,
      false,
      bmoon,
      bmoon,
      0xffdb4839
    );
    break;

  default:
    stage = new StageConfig();
    break;
}

// const stage1 = new StageConfig(0xff00afdb, 0xff00afdb, 0.0015, true, loadTexture('sun.png'), loadTexture('sun.png'));
// const stage2 = new StageConfig(0xffe8a05b, 0xffe8a05b, 0.0015, true, loadTexture('bsun.png'), loadTexture('bsun.png'));
// const stage3 = new StageConfig();
// const stage4 = new StageConfig(0xff000000, 0xff111111, 0.0015, false, loadTexture('bmoon.png'), loadTexture('bmoon.png'));
// const moonDisplacementMap = textureLoader.load('/static/3d/displacement.jpg');
// const moonTexture = ;
// const bmoon = textureLoader.load('/static/3d/bmoon.png');

const clock = new Clock();
const plotHeight = 1200;
const robotAab = new Box3();
const roboSize = new Vector3();

const buildingLength = 150;
const gutter = 30;
const questions = 4;

const keyPresses = {};
const scene = new Scene();
scene.background = new Color(stage.baseColor);
scene.fog = new FogExp2(stage.fogColor, stage.fogIntensity);

const globe = new Mesh(
  new SphereGeometry(2000),
  new MeshStandardMaterial({ color: stage.fogColor, side: BackSide })
);
scene.add(globe);

const devCam = new PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);
devCam.position.set(-70, 50, 20);

const playerCam = new PerspectiveCamera(
  30,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);
playerCam.position.set(-200, 70, 20);

let camera = playerCam;

function moveCameraUp() {}

function moveCameraDown() {}

let score = 0;
let totalTime = 0;
function displayLost(won = false) {
  const continueBtn = document.getElementById("nextButton");
  const restartBtn = document.getElementById("restartButton");
  const elm = document.getElementById("lostMessage");
  const message = document.getElementById("message");

  if (won) {
    message.textContent = "You Win";
    message.style.color = "green";
  }

  if (continueBtn) {
    continueBtn.onclick = () => {
      location.href = "/game/ransomeware/end";
    };
  }

  if (restartBtn) {
    restartBtn.onclick = () => {
      location.reload();
    };
  }

  if (elm) {
    elm.style.display = "flex";
  } else {
    setTimeout(() => {
      location.href =
        "/game/ransomeware/end?score=" + score + "&time=" + totalTime;
    }, 2000);
  }
}

const renderer = new WebGLRenderer({
  canvas: document.querySelector("#renderer"),
  antialias: true,
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

const axisHelper = new AxesHelper(600);

let stepCount = 0;
let questionData, questionController;
const robot = new Robot(async (robo) => {
  const model = robo.model;

  scene.add(model);

  robotAab.setFromObject(model);
  robotAab.getSize(roboSize);

  model.position.z = roboSize.z / 2;

  const respond = (correct, _score, _time) => {
    stepCount++;
    score = _score;
    totalTime = _time;
    if (correct) {
      let walkDistance = buildingLength - roboSize.z;
      if (stepCount == questionData.length) {
        walkDistance -= 30;
      }
      robo.pass(gutter + roboSize.z, walkDistance);
    } else {
      displayLost();
      robo.fail();
    }
  };

  const resp = await fetch("/res/questions.json");
  questionData = await resp.json();
  questionController = new QuestionController(questionData, respond);

  const next = () => {
    if (stepCount < questionData.length) {
      questionController.next();
    } else {
      robo.win();
      displayLost(true);
    }
  };

  robo.next = next;

  const colony = makeColony(questionData.length);
  colony.position.x = 400;
  const colonyAab = new Box3();
  colonyAab.setFromObject(colony);
  colony.position.add(
    new Vector3(0, -plotHeight, -(colonyAab.getSize(new Vector3()).z / 2))
  );
  scene.add(colony);

  requestAnimationFrame(onLoaded);
});

const ambientLight = new AmbientLight(0xffffff, 0.4);

const moonBody = new Mesh(
  new SphereGeometry(200, 1800, 1800),
  new MeshPhongMaterial({
    map: stage.moonTexture,
    displacementMap: stage.displacementMap,
    displacementScale: 0.0,
    bumpMap: stage.moonTexture,
    bumpScale: 0.04,
    reflectivity: 0,
    shininess: 0,
    emissive: stage.moonColor,
    emissiveMap: stage.moonTexture,
    emissiveIntensity: 12,
  })
);
const moon = new PointLight(0xffffff, 1, 5000);
moon.position.set(1200, 350, 0);
moonBody.position.set(1200, 350, 0);

const smokeC = makeSmoke();
smokeC.position.set(1300, 100, 0);

const smokeL = makeSmoke(650, 15);
smokeL.position.set(1100, 60, -window.innerWidth / 2);

const smokeR = makeSmoke(650, 15);
smokeR.position.set(1100, 70, window.innerWidth / 2);

//Spot light

const robotLight1 = new DirectionalLight(0xffffffff, 0.4);
const roboLight1Helper = new DirectionalLightHelper(robotLight1);
const robotLight2 = new DirectionalLight(0xffffffff, 0.4);
const roboLight2Helper = new DirectionalLightHelper(robotLight2);

// Clouds

const sphereCloud = getClouds(window.innerWidth);

sphereCloud.position.set(600, -window.innerWidth, 0);

// Cloud Cluster

const cloudCluster = getCloudCluster();
const clusterAab = new Box3();
clusterAab.setFromObject(cloudCluster);
const clusterCenter = clusterAab.getCenter(new Vector3());
cloudCluster.position.y - 300;
cloudCluster.position.x - 100;

const cloudLight = new PointLight(0xffffffff, 1, 8000, 0);
cloudLight.position.set(clusterCenter.x, clusterCenter.y, clusterCenter.z);

// Lily pad

const buildingAab = new Box3();

const buildings = [];
let offset = buildingLength / 2;
for (let i = 0; i < questions; i++) {
  const building = makeBuilding(50, 120, buildingLength);
  building.position.z = offset;
  offset += buildingLength + gutter;
  buildingAab.setFromObject(building);
  building.position.y = -(buildingAab.getSize(new Vector3()).y - 4);
  buildings.push(building);
}

const finishTexture = loadTexture("finish.png");
const finishSurface = new Mesh(
  new PlaneGeometry(120, 30),
  new MeshStandardMaterial({
    map: finishTexture,
    metalness: 0.001,
    roughness: 0.1,
  })
);
finishSurface.rotateX(-Math.PI / 2);
finishSurface.position.z = offset - (gutter + buildingLength);

// Scene

scene.add(
  axisHelper,
  ambientLight,
  moon,
  moonBody,
  smokeC,
  smokeL,
  smokeR,
  playerCam,
  robotLight1,
  robotLight2,
  roboLight1Helper,
  roboLight2Helper,
  sphereCloud,
  cloudCluster,
  finishSurface,
  ...buildings
);

renderer.render(scene, camera);

const controls = new OrbitControls(devCam, renderer.domElement);

function onLoaded() {
  document.getElementById("loading").style.zIndex = 0;
  robot.wave();
  robot.walk(buildingLength - roboSize.z);
  gameLoop();
}

let camX = 0,
  camZ = 0;

function gameLoop() {
  requestAnimationFrame(gameLoop);

  const delta = clock.getDelta();

  const cameraSpeed = 50;
  if (keyPresses["w"]) {
    camX += delta * cameraSpeed;
  } else if (keyPresses["s"]) {
    camX -= delta * cameraSpeed;
  }

  if (keyPresses["a"]) {
    camZ -= delta * cameraSpeed;
  } else if (keyPresses["d"]) {
    camZ += delta * cameraSpeed;
  }

  moonBody.rotateY(0.0001);
  moonBody.rotateZ(0.0002);

  if (robot.model) {
    const roboModel = robot.model;
    const robotPos = roboModel.position.clone();

    robotLight1.position.set(robotPos.x - 100, robotPos.y + 50, robotPos.z);
    robotLight1.target.position.set(robotPos.x, robotPos.y, robotPos.z);
    robotLight1.target.updateWorldMatrix();

    robotLight2.position.set(robotPos.x, robotPos.y + 100, robotPos.z);
    robotLight2.target.position.set(robotPos.x, robotPos.y, robotPos.z);
    robotLight2.target.updateWorldMatrix();

    playerCam.position.set(robotPos.x, robotPos.y, robotPos.z);
    playerCam.position.add(new Vector3(-400 + camX, 100, 20 + camZ));
    playerCam.lookAt(
      roboModel.position.clone().add(new Vector3(0 + camX, 70, 20 + camZ))
    );
  }

  if (keyPresses["f"]) {
    robot.fail();
  } else if (keyPresses["p"]) {
    robot.pass(gutter + roboSize.z, buildingLength - roboSize.z);
  }

  smokeC.rotation.y += 0.0001;
  smokeC.rotation.x += stage.slowStars ? 0.0002 : 0.0005;
  smokeL.rotation.y += 0.0001;
  smokeL.rotation.x += stage.slowStars ? 0.0003 : 0.0005;
  smokeR.rotation.y += 0.0001;
  smokeR.rotation.x += stage.slowStars ? 0.0004 : 0.0005;

  controls.update();

  renderer.render(scene, camera);
}

function keyPressTracker(ev) {
  console.log(ev.key);
  keyPresses[ev.key] = ev.type == "keydown";
  if (ev.key == "c" && ev.type != "keydown") {
    camX = 0;
    camZ = 0;
  }
}

function changeCamera() {
  if (camera.uuid == devCam.uuid) {
    camera = playerCam;
  } else {
    camera = devCam;
  }
}

window.onkeyup = keyPressTracker;
window.onkeydown = keyPressTracker;

// const btn = document.getElementById('btn');
// if (btn != null) {
//   btn.addEventListener('click', (ev) => {
// if (camera.uuid == devCam.uuid) {
//   camera = playerCam;
// } else {
//   camera = devCam;
// }
//   })
// }

window.changeCamera = changeCamera;

import './style.css'
import * as three from "three";
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { Robot } from './robot';
import { AxesHelper, BackSide, Box3, CameraHelper, Color, DirectionalLight, DirectionalLightHelper, FogExp2, Mesh, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, PlaneGeometry, PointLight, SphereGeometry, TextureLoader, Vector3 } from 'three';
import { getRandom } from "./utils";
import { makeSmoke } from './smoke';
import { makeColony } from './building_colony';
import { getClouds } from './clouds';
import { makePad } from './pad';
import { getCloudCluster } from './cloud_cluster';
import { makeBuilding } from './building';
import { QuestionController } from './game_them';

const resp = await fetch('/res/questions.json');
const questionData = await resp.json();
const questionController = new QuestionController(questionData);
window.onclick = () => {
  questionController.next();
}

const clock = new three.Clock();
const textureLoader = new TextureLoader();
const plotHeight = 1200;
const robotAab = new Box3();
const roboSize = new Vector3();

const buildingLength = 150;
const gutter = 30;
const padDistance = 120;
const questions = 4;

const keyPresses = {};
const scene = new three.Scene();
scene.background = new Color(0xff000000);
scene.fog = new FogExp2(0xff111111, 0.0015);

const globe = new Mesh(new SphereGeometry(2000), new MeshStandardMaterial({ color: 0xff000000, side: BackSide }));
scene.add(globe);


const devCam = new three.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
devCam.position.set(-70, 50, 20);

const playerCam = new three.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 5000);
playerCam.position.set(-150, 70, 20);
const cameraHelper = new CameraHelper(playerCam);

let camera = playerCam;


const renderer = new three.WebGLRenderer({ canvas: document.querySelector('#renderer'), antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

const gridHelper = new three.GridHelper(400, 50);
const axisHelper = new AxesHelper(600);

const robot = new Robot((robo) => {
  console.log(robo);
  const model = robo.model;
  model.animations.forEach((clip, index, arr) => {
    console.log(index + clip.name + clip.duration);
  })
  scene.add(model);
  robotAab.setFromObject(model);
  robotAab.getSize(roboSize);
  console.log(roboSize);
  model.position.z = robotAab.getSize(new Vector3()).z / 2;
  robo.walk(buildingLength - roboSize.z);
});

const ambientLight = new three.AmbientLight(0xffffff, 0.4);

const moonDisplacementMap = textureLoader.load('displacement.jpg');
const moonTexture = textureLoader.load('moon.jpg');
const moonBody = new Mesh(new SphereGeometry(200, 1800, 1800), new MeshPhongMaterial({ map: moonTexture, displacementMap: moonDisplacementMap, displacementScale: 0.0, bumpMap: moonDisplacementMap, bumpScale: 0.04, reflectivity: 0, shininess: 0, emissive: 0xffffffff, emissiveMap: moonTexture, emissiveIntensity: 12 }));
const moon = new three.PointLight(0xffffff, 1, 5000);
moon.position.set(1200, 350, 0);
moonBody.position.set(1200, 350, 0);

const thrid = window.innerWidth / 5;

const smokeC = makeSmoke();
smokeC.position.set(1300, 100, 0);

const smokeL = makeSmoke(650, 15);
smokeL.position.set(1100, 60, -window.innerWidth / 2);

const smokeR = makeSmoke(650, 15);
smokeR.position.set(1100, 70, window.innerWidth / 2);

const colony = makeColony();
colony.position.x = 400;
const colonyAab = new Box3();
colonyAab.setFromObject(colony);
colony.position.add(new Vector3(0, -plotHeight, -(colonyAab.getSize(new Vector3()).z / 2)));

//Spot light

const robotLight1 = new DirectionalLight(0xffffffff, 0.4);
const roboLight1Helper = new DirectionalLightHelper(robotLight1);
const robotLight2 = new DirectionalLight(0xffffffff, 0.4);
const roboLight2Helper = new DirectionalLightHelper(robotLight2);

// Surface

// const cloudMap = textureLoader.load('cloud.png');

// const surface = new Mesh(
//   new PlaneGeometry(1000, 1000, 100, 100),
//   new MeshPhysicalMaterial({
//     color: 0xffffffff,
//     wireframe: true,
//     // side: DoubleSide,
//     transparent: true,
//     map: cloudMap,
//     alphaMap: cloudMap,
//     displacementMap: cloudMap,
//     displacementBias: 60,
//     // bumpMap: cloudMap,
//     // bumpScale: 60,
//     envMap: cloudMap,
//   }),
// )
// surface.rotation.set(0, 0, Math.PI);
// surface.rotation.set(-Math.PI / 20, 0);
// surface.position.set(400, -330, 0);

// Clouds

const sphereCloud = getClouds(window.innerWidth);
// const cloudAab = new Box3();
// cloudAab.setFromObject(sphereCloud);
// cloudCluster.position.set(400, -600, -cloudAab.getSize(new Vector3()).z/2);
sphereCloud.position.set(600, -window.innerWidth, 0);

// Cloud Cluster

const cloudCluster = getCloudCluster();
const clusterAab = new Box3();
clusterAab.setFromObject(cloudCluster);
const clusterCenter = clusterAab.getCenter(new Vector3());
cloudCluster.position.y - 300;
cloudCluster.position.x - 100;

const cloudLight = new PointLight(0xffffffff, 1, 8000, 0);
cloudLight.position.set(clusterCenter.x, clusterCenter.y, clusterCenter.z);



// Lily pad

const buildingAab = new Box3();

const buildings = [];
let offset = buildingLength / 2;
for (let i = 0; i < questions; i++) {
  const building = makeBuilding(50, 120, buildingLength);
  building.position.z = offset;
  offset += buildingLength + gutter;
  buildingAab.setFromObject(building);
  building.position.y = -buildingAab.getSize(new Vector3()).y;
  buildings.push(building);
}

const lastBuilding = makeBuilding(50, 120, buildingLength);
lastBuilding.position.z = offset;
buildingAab.setFromObject(lastBuilding);
lastBuilding.position.y = -buildingAab.getSize(new Vector3()).y;
buildings.push(lastBuilding);


scene.add(
  // gridHelper,
  axisHelper,
  ambientLight,
  moon,
  moonBody,
  smokeC,
  smokeL,
  smokeR,
  // cameraHelper,
  playerCam,
  colony,
  robotLight1,
  robotLight2,
  roboLight1Helper,
  roboLight2Helper,
  // surface,
  sphereCloud,
  cloudCluster,
  // cloudLight,
  ...buildings,
);

renderer.render(scene, camera);

const controls = new OrbitControls(devCam, renderer.domElement);

// const sunOrbitRadius = 200;
// const sunOrbitSpeed = 1;
// let sunAngle = 0;

// function rotateSun(delta = 1) {
//   sunAngle += sunOrbitSpeed * delta;
//   const y = Math.sin(sunAngle) * sunOrbitRadius;
//   const z = Math.cos(sunAngle) * sunOrbitRadius;
//   moon.position.y = y;
//   moon.position.z = z;
//   moonBody.position.y = y;
//   moonBody.position.z = z;
// }

function gameLoop() {
  requestAnimationFrame(gameLoop);

  // cloudCluster.lookAt(playerCam.position);
  // // cloudCluster.rotateX(-Math.PI / 2);
  // cloudCluster.rotateZ(-Math.PI / 2);
  let robotLength = 0;


  moonBody.rotateY(0.0001);
  moonBody.rotateZ(0.0002);

  if (robot.model) {
    robotLength = robotAab.getSize(new Vector3()).z;
    const roboModel = robot.model;
    const robotPos = roboModel.position.clone();

    robotLight1.position.set(robotPos.x - 100, robotPos.y + 50, robotPos.z);
    robotLight1.target.position.set(robotPos.x, robotPos.y, robotPos.z);
    robotLight1.target.updateWorldMatrix();

    robotLight2.position.set(robotPos.x, robotPos.y + 100, robotPos.z);
    robotLight2.target.position.set(robotPos.x, robotPos.y, robotPos.z);
    robotLight2.target.updateWorldMatrix();

    playerCam.position.set(robotPos.x, robotPos.y, robotPos.z);
    playerCam.position.add(new Vector3(-300, 70, 20));
    playerCam.lookAt(roboModel.position.clone().add(new Vector3(0, 50, 20)));
  }

  const delta = clock.getDelta();
  // rotateSun(delta);

  if (keyPresses['f']) {
    robot.fail()

  } else if (keyPresses['p']) {
    robot.pass(gutter + roboSize.z, buildingLength - roboSize.z);
  }

  // if (keyPresses['w'] == true) {
  //   robot.walk();
  // }
  // if (keyPresses['a']) {
  //   robot.rotate(0.1);
  // } else if (keyPresses['d']) {
  //   robot.rotate(-0.1);
  // }
  // if (keyPresses[' ']) {
  //   robot.jump(20 + (robotLength));
  // }
  // if (keyPresses['Control']) {
  //   robot.punch();
  // }

  smokeC.rotation.y += 0.0001;
  smokeC.rotation.x += 0.0005;
  smokeL.rotation.y += 0.0001;
  smokeL.rotation.x += 0.0005;
  smokeR.rotation.y += 0.0001;
  smokeR.rotation.x += 0.0005;

  // sphereCloud.rotation.x += 0.00001;

  controls.update();


  renderer.render(scene, camera);
}

function keyPressTracker(ev) {
  console.log(ev.key);
  keyPresses[ev.key] = ev.type == 'keydown';
}

window.onkeyup = keyPressTracker;
window.onkeydown = keyPressTracker;

// const btn = document.getElementById('btn');
// if (btn != null) {
//   btn.addEventListener('click', (ev) => {
//     if (camera.uuid == devCam.uuid) {
//       camera = playerCam;
//     } else {
//       camera = devCam;
//     }
//   })
// }

gameLoop();

export { getRandom };

window.playerCam = playerCam;
// window.surface = surface;